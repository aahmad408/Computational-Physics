# -*- coding: utf-8 -*-
"""Random Walk

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11InaIyFqoP809NpomFTY_xjXOkL5bhup

**PART A**
"""

import numpy as np
import matplotlib.pyplot as plt


n_step = 100

n_w = 20000

grid = np.array([[1, 0], [0, 1], [-1, 0], [0, -1]])

r2 = np.zeros(n_step+1)

# loop over walks
for w in range(n_w):

    x, y = 0, 0

    #steps loop
    for n in range(1, n_step+1):

        # random step from grid
        step = grid[np.random.randint(len(grid))]

        x += step[0]

        y += step[1]

        #displacement squared and add to the average
        r2[n] += x**2 + y**2

#avg over number of walks
r2 /= n_w

#plot
n1 = np.arange(1, n_step+1)
plt.plot(n1, r2[1:], '.')
plt.xlabel('n')
plt.ylabel('<r^2>')
plt.show()

"""###The plot is approximately linear with n, which is linear with time. This means the square root of r^2 is of order square root time. So, this yields a Flory exponent value ν ≈ 1/2

**PART B**
"""

n2_max = 50
n2_w = 100000

grid = np.array([[1, 0], [0, 1], [-1, 0], [0, -1]])

# displacement squared each step
saw_r2 = np.zeros(n2_max+1)

# loop over walks
for w in range(n2_w):

    x, y = 0, 0

    used = [(x, y)]



    # steps loop
    for n in range(1, n2_max+1):

      while True:
        step2 = grid[np.random.randint(len(grid))]
        x += step2[0]
        y += step2[1]


        if (x, y) not in used:
            used.append((x, y))
            saw_r2[n] += x**2 + y**2
            break


        while True:
            step2 = grid[np.random.randint(len(grid))]
            x = x + step2[0]
            y = y + step2[1]

            if (x, y) not in used:
                used.append((x, y))
                saw_r2[n] += x**2 + y**2
                break



        # add to used position
        used.append((x, y))


        # displacement squared add to the average
        saw_r2[n] += x**2 + y**2


# avg over the number of walks
saw_r2 /= n2_w

n2 = np.arange(1, n2_max+1)
plt.plot(n2, saw_r2[1:], '-')
plt.xlabel('n')
plt.ylabel('<r^2>')
plt.show()

rs = []
for i in range(2, len(saw_r2)-1):
  rs.append(saw_r2[i+1]/saw_r2[i])
over_n = []
for i in range(2, len(saw_r2)-1):
  over_n.append(1/(i))

plt.scatter(over_n, rs)
plt.xlabel('1/n')
plt.ylabel('<r^2 n+1> / <r^2 n>')

from scipy import optimize

def function(x, m, b):
  y = m*x + b
  return y

fit = optimize.curve_fit(function, xdata=over_n, ydata=rs)

"""###The slope of this is 2ν so v is half the slope

### 2v ≈ (1.8-1)/.5    ------>   v ≈ 0.8 which is close to expected value

###For the Flory exponent from part a ....
"""

n1 = np.arange(1, n_step+1)
a, b = np.polyfit(n1,r2[1:],1)
print(a/2)

"""### which is ≈ 1/2

**PART C**
"""

n_step = 100
n_w = 20000
grid = np.array([[1, 0], [0, 1], [-1, 0], [0, -1]])
r2 = np.zeros(n_step+1)
r2_variance = np.zeros(n_step+1)

# loop over walks
for w in range(n_w):
    x, y = 0, 0

    #steps loop
    for n in range(1, n_step+1):

        step = grid[np.random.randint(len(grid))]
        x += step[0]
        y += step[1]

        #displacement squared add to the average
        r2[n] += x**2 + y**2
        r2_variance[n] += (x**2 + y**2)**2

#avg over number of walks and variance
r2 /= n_w
r2_variance /= n_w
r2_variance -= r2**2


plt.plot(range(1, n_step+1), r2_variance[1:])
plt.xlabel('n')
plt.ylabel('$\Delta$ r^2_n')
plt.title('Fluctuations in Random Walk')
plt.show()

rs2 = []
for i in range(4, len(r2_variance)-1):
  rs2.append(r2_variance[i+1]/r2_variance[i])
over_n = []
for i in range(4, len(r2_variance)-1):
  over_n.append(1/(i+4))

a, b = np.polyfit(over_n, rs2,1)
print(a/2)

"""###above is the exponent x, which aligns with the plot

"""